#!/bin/bash

# ==============================================================================
# Ollama Context Window Variant Generator
#
# Description:
# This script manages Ollama model variants with different context window sizes.
# - Works with older Ollama versions by parsing plain text.
# - Prevents silent exits if model details can't be parsed.
# - Sanitizes model names containing slashes (e.g., "namespace/model")
#   to create valid filenames.
#
# Commands:
# - ctx --create: Create model variants with different context sizes
# - ctx --delete: Delete generated model variants and their Modelfiles
#
# ==============================================================================

set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # The return value of a pipeline is the status of the last command to exit with a non-zero status.

# --- Configuration ---
OUTPUT_DIR="$HOME/dev/ollama/Modelfiles"
START_CONTEXT=8192

# --- Functions ---

is_conforming_model_name() {
    local model_tag="$1"
    
    # Check if model follows the proper Ollama naming convention:
    # [MODEL_NAME]:[SIZE]-[TYPE]-[QUANTIZATION] or [MODEL_NAME]:[SIZE]
    # Examples: llama3.1:8b-instruct-q4_K_M, qwen2.5:14b, microsoft/DialoGPT:medium
    
    # Skip if it's our generated context variant (ends with -NNk)
    if [[ "$model_tag" =~ -[0-9]+k$ ]]; then
        return 0  # Consider our variants as conforming
    fi
    
    # Must contain a colon
    if [[ ! "$model_tag" =~ : ]]; then
        return 1
    fi
    
    # Extract the tag part (after colon)
    local tag_part=$(echo "$model_tag" | cut -d':' -f2)
    
    # Check for problematic patterns:
    # 1. Size in model name before colon (e.g., "model-6.7B-instruct:Q4_K_M")
    if [[ "$model_tag" =~ ^(.+)-([0-9]+\.?[0-9]*[BM])-(.+):(.+)$ ]]; then
        return 1
    fi
    
    # 2. Size in model name before colon without middle part (e.g., "model-30B:Q8_0")
    if [[ "$model_tag" =~ ^(.+)-([0-9]+\.?[0-9]*[BM]):(.+)$ ]]; then
        return 1
    fi
    
    # If we get here, the model appears to follow proper convention
    return 0
}

show_naming_warning() {
    local model_tag="$1"
    
    echo ""
    echo -e "\033[1;31m╔══════════════════════════════════════════════════════════════════════════════╗\033[0m"
    echo -e "\033[1;31m║                              ⚠️  NAMING CONVENTION WARNING ⚠️                   ║\033[0m"
    echo -e "\033[1;31m╚══════════════════════════════════════════════════════════════════════════════╝\033[0m"
    echo ""
    echo -e "\033[1;33mModel '$model_tag' does not follow Ollama naming conventions.\033[0m"
    echo ""
    echo -e "\033[1;37mOllama models should follow this format:\033[0m"
    echo -e "\033[1;32m  [MODEL_NAME]:[SIZE]-[TYPE]-[QUANTIZATION]\033[0m"
    echo ""
    echo -e "\033[1;37mExamples of CORRECT naming:\033[0m"
    echo -e "\033[1;32m  ✓ llama3.1:8b-instruct-q4_K_M\033[0m"
    echo -e "\033[1;32m  ✓ qwen2.5:14b\033[0m"
    echo -e "\033[1;32m  ✓ microsoft/DialoGPT:medium\033[0m"
    echo ""
    echo -e "\033[1;37mExamples of INCORRECT naming:\033[0m"
    echo -e "\033[1;31m  ✗ model-6.7B-instruct:Q4_K_M  (size in wrong place)\033[0m"
    echo -e "\033[1;31m  ✗ model-30B:Q8_0              (size in wrong place)\033[0m"
    echo ""
    echo -e "\033[1;36mTo fix this, run:\033[0m"
    echo -e "\033[1;37m  ./ollama-mama model --autorename\033[0m"
    echo ""
}

show_usage() {
    echo "Usage: $0 [ctx|model] [options]"
    echo ""
    echo "Context Commands:"
    echo "  ctx --create              Create model variants with different context window sizes"
    echo "  ctx --delete              Delete generated model variants and their Modelfiles"
    echo "  ctx --delete-base <model> Delete a specific base model and all its variants"
    echo "  ctx --create-base <model> Create variants for a specific base model only"
    echo "  ctx --list [filter]       List base models with context window information"
    echo ""
    echo "Model Commands:"
    echo "  model --autorename        Auto-rename models with problematic naming patterns"
    echo ""
    echo "Examples:"
    echo "  $0 ctx --create"
    echo "  $0 ctx --delete"
    echo "  $0 ctx --delete-base fredrezones55/unsloth-deepseek-r1:8b"
    echo "  $0 ctx --create-base fredrezones55/unsloth-deepseek-r1:8b"
    echo "  $0 ctx --list"
    echo "  $0 ctx --list llama"
    echo "  $0 model --autorename"
}

create_variants_for_model() {
    local model_tag="$1"
    local param_size="$2"
    local max_ctx="$3"
    local overwrite_all="$4"

    params_sanitized=$(echo "$param_size" | tr '[:upper:]' '[:lower:]' | sed -E 's/\..*b/b/')
    
    # --- MODIFICATION START: Sanitize model name for filename ---
    # Get the base name, which might contain a slash (e.g., "namespace/model")
    model_base_name_raw=$(echo "$model_tag" | cut -d':' -f1)
    # Sanitize the name for use in filenames by replacing any '/' with a '-'
    model_base_name=$(echo "$model_base_name_raw" | tr '/' '-')
    # --- MODIFICATION END ---

    echo "INFO: Found Model: $model_base_name_raw | Parameters: $param_size | Max Context: ${max_ctx} tokens"

    current_ctx=$START_CONTEXT
    while [ "$current_ctx" -le "$max_ctx" ]; do
        context_k=$((current_ctx / 1024))
        # Use the raw (un-sanitized) name for the new Ollama tag, but the sanitized one for the filename
        new_tag_name="${model_base_name_raw}:${params_sanitized}-${context_k}k"
        modelfile_name="my-${model_base_name}-${params_sanitized}-${context_k}k.modelfile"
        modelfile_path="$OUTPUT_DIR/$modelfile_name"

        echo " -> Preparing variant: $new_tag_name"

        if [ "$overwrite_all" = false ] && (ollama list | grep -q "^${new_tag_name}\s" || [ -f "$modelfile_path" ]); then
            echo "    SKIPPED: Variant '$new_tag_name' or Modelfile '$modelfile_name' already exists."
            current_ctx=$((current_ctx * 2))
            continue
        fi

        cat > "$modelfile_path" << EOM
# Modelfile for ${new_tag_name}
# Generated by script on $(date)

FROM ${model_tag}

# Set the new context window size
PARAMETER num_ctx ${current_ctx}
EOM

        echo "    CREATED Modelfile: $modelfile_path"
        echo "    CREATING Ollama model '$new_tag_name'..."
        if ollama create "$new_tag_name" -f "$modelfile_path"; then
            echo "    SUCCESS: Created '$new_tag_name'."
        else
            echo "    ERROR: Failed to create '$new_tag_name'. Check logs above."
        fi

        current_ctx=$((current_ctx * 2))
    done
}

create_models() {

    mkdir -p "$OUTPUT_DIR"
    echo "INFO: Modelfiles will be saved in '$OUTPUT_DIR'"

    OVERWRITE_ALL=false
    read -p "Do you want to overwrite existing Modelfiles and recreate models? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        OVERWRITE_ALL=true
        echo "INFO: Overwrite enabled. Existing files will be replaced."
    else
        echo "INFO: Overwrite disabled. Existing models/files will be skipped."
    fi

    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)

    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    echo "--- Starting Model Scan ---"

    # First pass: Check for non-conforming models
    NON_CONFORMING_MODELS=()
    for model_tag in $ALL_MODEL_TAGS; do
        # Skip our generated context variants
        if [[ "$model_tag" =~ :[^:]*-[0-9]+k$ ]]; then
            continue
        fi
        
        # Skip derived models
        modelfile_content=$(ollama show --modelfile "$model_tag" 2>/dev/null || echo "")
        if echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
            continue
        fi
        
        # Check if model follows naming convention
        if ! is_conforming_model_name "$model_tag"; then
            NON_CONFORMING_MODELS+=("$model_tag")
        fi
    done

    # If non-conforming models found, show warning and exit
    if [ ${#NON_CONFORMING_MODELS[@]} -gt 0 ]; then
        echo ""
        echo -e "\033[1;31m╔══════════════════════════════════════════════════════════════════════════════╗\033[0m"
        echo -e "\033[1;31m║                         ⚠️  NON-CONFORMING MODELS DETECTED ⚠️                  ║\033[0m"
        echo -e "\033[1;31m╚══════════════════════════════════════════════════════════════════════════════╝\033[0m"
        echo ""
        echo -e "\033[1;33mFound ${#NON_CONFORMING_MODELS[@]} model(s) that don't follow Ollama naming conventions:\033[0m"
        echo ""
        for model in "${NON_CONFORMING_MODELS[@]}"; do
            echo -e "\033[1;31m  ✗ $model\033[0m"
        done
        echo ""
        echo -e "\033[1;37mOllama models should follow this format:\033[0m"
        echo -e "\033[1;32m  [MODEL_NAME]:[SIZE]-[TYPE]-[QUANTIZATION]\033[0m"
        echo ""
        echo -e "\033[1;37mExamples of CORRECT naming:\033[0m"
        echo -e "\033[1;32m  ✓ llama3.1:8b-instruct-q4_K_M\033[0m"
        echo -e "\033[1;32m  ✓ qwen2.5:14b\033[0m"
        echo -e "\033[1;32m  ✓ microsoft/DialoGPT:medium\033[0m"
        echo ""
        echo -e "\033[1;36mTo fix these models, run:\033[0m"
        echo -e "\033[1;37m  ./ollama-mama model --autorename\033[0m"
        echo ""
        echo -e "\033[1;33mContext variant creation cannot proceed until all models follow proper naming conventions.\033[0m"
        echo ""
        exit 1
    fi

    # Second pass: Process conforming models
    for model_tag in $ALL_MODEL_TAGS; do
        echo "---"
        echo "Processing Tag: $model_tag"

        # Skip our generated context variants
        if [[ "$model_tag" =~ :[^:]*-[0-9]+k$ ]]; then
            echo "INFO: Skipping '$model_tag' as it is a generated context variant."
            continue
        fi

        modelfile_content=$(ollama show --modelfile "$model_tag")

        if echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
            from_model=$(echo "$modelfile_content" | grep '^FROM' | awk '{print $2}')
            echo "INFO: Skipping '$model_tag' as it is derived from '$from_model'."
            continue
        fi
        echo "INFO: '$model_tag' identified as a conforming base model."

        model_info_text=$(ollama show "$model_tag")

        param_size=$(echo "$model_info_text" | grep 'parameters' | awk '{print $2}' || true)
        max_ctx=$(echo "$model_info_text" | grep 'context length' | awk '{print $3}' || true)

        if [ -z "$param_size" ] || [ -z "$max_ctx" ]; then
            echo "WARNING: Could not determine parameter size or max context for '$model_tag'. Skipping."
            continue
        fi

        create_variants_for_model "$model_tag" "$param_size" "$max_ctx" "$OVERWRITE_ALL"
    done

    echo "---"
    echo "Script finished."
}

create_base_model() {
    local base_model="$1"
    
    echo "--- Starting Base Model Variant Creation ---"
    echo "Target base model: $base_model"
    
    mkdir -p "$OUTPUT_DIR"
    echo "INFO: Modelfiles will be saved in '$OUTPUT_DIR'"

    # Check if model exists in Ollama
    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)
    
    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    MODEL_EXISTS=false
    for model_tag in $ALL_MODEL_TAGS; do
        if [ "$model_tag" = "$base_model" ]; then
            MODEL_EXISTS=true
            break
        fi
    done

    if [ "$MODEL_EXISTS" = false ]; then
        echo "ERROR: Model '$base_model' not found in Ollama."
        echo "Available models:"
        echo "$ALL_MODEL_TAGS" | sed 's/^/  - /'
        exit 1
    fi

    # Check if it's a variant (ends with -NNk pattern)
    if [[ "$base_model" =~ -[0-9]+k$ ]]; then
        echo "ERROR: '$base_model' appears to be a variant model (ends with -NNk)."
        echo "Please specify a base model instead."
        exit 1
    fi

    # Check if it's derived from another model
    modelfile_content=$(ollama show --modelfile "$base_model")
    if echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
        from_model=$(echo "$modelfile_content" | grep '^FROM' | awk '{print $2}')
        echo "ERROR: '$base_model' is derived from '$from_model'."
        echo "Please specify a base model instead."
        exit 1
    fi

    # Check if model follows naming convention
    if ! is_conforming_model_name "$base_model"; then
        show_naming_warning "$base_model"
        echo "ERROR: Cannot create variants for non-conforming model '$base_model'."
        echo "Please run './ollama-mama model --autorename' first to fix the naming."
        exit 1
    fi

    echo "INFO: '$base_model' validated as a conforming base model."

    # Get overwrite preference
    OVERWRITE_ALL=false
    read -p "Do you want to overwrite existing Modelfiles and recreate models? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        OVERWRITE_ALL=true
        echo "INFO: Overwrite enabled. Existing files will be replaced."
    else
        echo "INFO: Overwrite disabled. Existing models/files will be skipped."
    fi

    # Get model information
    model_info_text=$(ollama show "$base_model")

    param_size=$(echo "$model_info_text" | grep 'parameters' | awk '{print $2}' || true)
    max_ctx=$(echo "$model_info_text" | grep 'context length' | awk '{print $3}' || true)

    if [ -z "$param_size" ] || [ -z "$max_ctx" ]; then
        echo "ERROR: Could not determine parameter size or max context for '$base_model'."
        echo "This might indicate an issue with the model or Ollama version compatibility."
        exit 1
    fi

    echo "---"
    echo "Processing Tag: $base_model"

    # Create variants using the extracted function
    create_variants_for_model "$base_model" "$param_size" "$max_ctx" "$OVERWRITE_ALL"

    echo "---"
    echo "Base model variant creation completed."
}

delete_models() {
    echo "--- Starting Model Deletion ---"
    
    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)

    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    # Find generated models (those matching the pattern {model}:{params}-{context}k)
    GENERATED_MODELS=()
    for model_tag in $ALL_MODEL_TAGS; do
        # Check if model matches the generated pattern: contains colon and ends with -NNk
        if [[ "$model_tag" =~ :[^:]*-[0-9]+k$ ]]; then
            GENERATED_MODELS+=("$model_tag")
        fi
    done

    if [ ${#GENERATED_MODELS[@]} -eq 0 ]; then
        echo "INFO: No generated model variants found to delete."
        return 0
    fi

    echo "Found ${#GENERATED_MODELS[@]} generated model variant(s):"
    for model in "${GENERATED_MODELS[@]}"; do
        echo "  - $model"
    done
    echo ""

    # Find corresponding Modelfiles
    MODELFILES_TO_DELETE=()
    if [ -d "$OUTPUT_DIR" ]; then
        for modelfile in "$OUTPUT_DIR"/my-*-*k.modelfile; do
            if [ -f "$modelfile" ]; then
                MODELFILES_TO_DELETE+=("$modelfile")
            fi
        done
    fi

    if [ ${#MODELFILES_TO_DELETE[@]} -gt 0 ]; then
        echo "Found ${#MODELFILES_TO_DELETE[@]} corresponding Modelfile(s):"
        for modelfile in "${MODELFILES_TO_DELETE[@]}"; do
            echo "  - $(basename "$modelfile")"
        done
        echo ""
    fi

    # Confirmation prompt
    echo "This will delete:"
    echo "  - ${#GENERATED_MODELS[@]} Ollama model variant(s)"
    echo "  - ${#MODELFILES_TO_DELETE[@]} Modelfile(s)"
    echo ""
    read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "INFO: Deletion cancelled."
        return 0
    fi

    # Delete Ollama models
    echo "--- Deleting Ollama Models ---"
    for model in "${GENERATED_MODELS[@]}"; do
        echo "Deleting model: $model"
        if ollama rm "$model"; then
            echo "  SUCCESS: Deleted '$model'"
        else
            echo "  ERROR: Failed to delete '$model'"
        fi
    done

    # Delete Modelfiles
    if [ ${#MODELFILES_TO_DELETE[@]} -gt 0 ]; then
        echo "--- Deleting Modelfiles ---"
        for modelfile in "${MODELFILES_TO_DELETE[@]}"; do
            echo "Deleting file: $(basename "$modelfile")"
            if rm -f "$modelfile"; then
                echo "  SUCCESS: Deleted '$(basename "$modelfile")'"
            else
                echo "  ERROR: Failed to delete '$(basename "$modelfile")'"
            fi
        done
    fi

    echo "---"
    echo "Deletion completed."
}

delete_base_model() {
    local base_model="$1"
    
    echo "--- Starting Base Model Deletion ---"
    echo "Target base model: $base_model"
    
    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)

    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    # Extract model name part for comprehensive variant searching
    model_name_part=$(echo "$base_model" | cut -d':' -f1)
    
    # Try to resolve the base model and find all potential variants
    RESOLVED_BASE_MODEL=""
    BASE_MODEL_EXISTS=false
    MODELS_TO_DELETE=()
    VARIANT_MATCHES=()
    
    # First, check if the exact model exists
    for model_tag in $ALL_MODEL_TAGS; do
        if [ "$model_tag" = "$base_model" ]; then
            BASE_MODEL_EXISTS=true
            RESOLVED_BASE_MODEL="$base_model"
            MODELS_TO_DELETE+=("$base_model")
            break
        fi
    done
    
    # If not found and it's a :latest alias, try to find the actual base model
    if [ "$BASE_MODEL_EXISTS" = false ] && [[ "$base_model" =~ :latest$ ]]; then
        echo "INFO: '$base_model' not found directly. Searching for actual base models of '$model_name_part'..."
        
        # Look for any base model with the same name part but different tag
        for model_tag in $ALL_MODEL_TAGS; do
            if [[ "$model_tag" =~ ^${model_name_part}: ]] && [[ ! "$model_tag" =~ -[0-9]+k$ ]]; then
                # Check if it's actually a base model (not derived)
                modelfile_content=$(ollama show --modelfile "$model_tag" 2>/dev/null || echo "")
                if ! echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
                    echo "INFO: Found actual base model '$model_tag' for alias '$base_model'"
                    RESOLVED_BASE_MODEL="$model_tag"
                    BASE_MODEL_EXISTS=true
                    MODELS_TO_DELETE+=("$model_tag")
                    break
                fi
            fi
        done
    fi
    
    # If still not found, use the original name for variant matching
    if [ -z "$RESOLVED_BASE_MODEL" ]; then
        RESOLVED_BASE_MODEL="$base_model"
    fi

    echo "INFO: Searching for variants of model family '$model_name_part'..."
    
    # Comprehensive variant search using multiple strategies
    for model_tag in $ALL_MODEL_TAGS; do
        # Skip the base model itself (already added if it exists)
        if [ "$model_tag" = "$base_model" ] || [ "$model_tag" = "$RESOLVED_BASE_MODEL" ]; then
            continue
        fi
        
        # Skip if not a variant (doesn't end with -NNk)
        if [[ ! "$model_tag" =~ -[0-9]+k$ ]]; then
            continue
        fi
        
        # Strategy 1: Direct variant matching (exact base model match)
        # e.g., "llama3.1:8b-instruct-q4_K_M-16k" -> "llama3.1:8b-instruct-q4_K_M"
        if [[ "$model_tag" =~ ^(.+)-[0-9]+k$ ]]; then
            variant_base="${BASH_REMATCH[1]}"
            if [ "$variant_base" = "$RESOLVED_BASE_MODEL" ] || [ "$variant_base" = "$base_model" ]; then
                MODELS_TO_DELETE+=("$model_tag")
                VARIANT_MATCHES+=("Direct match: $model_tag -> $variant_base")
                continue
            fi
        fi
        
        # Strategy 2: Model family matching (same model name, any tag with -Nk suffix)
        # e.g., "llama3.1:8b-16k" could be variant of "llama3.1:8b" or "llama3.1:latest"
        if [[ "$model_tag" =~ ^${model_name_part}:(.+)-[0-9]+k$ ]]; then
            variant_tag_part="${BASH_REMATCH[1]}"
            potential_base="${model_name_part}:${variant_tag_part}"
            
            # Check if this variant could belong to our target base model
            # Case 1: Direct match with resolved base
            if [ "$potential_base" = "$RESOLVED_BASE_MODEL" ] || [ "$potential_base" = "$base_model" ]; then
                MODELS_TO_DELETE+=("$model_tag")
                VARIANT_MATCHES+=("Family match: $model_tag -> $potential_base")
                continue
            fi
            
            # Case 2: Handle :latest alias - if user specified model:latest, 
            # match variants from any tag of that model
            if [[ "$base_model" =~ :latest$ ]]; then
                MODELS_TO_DELETE+=("$model_tag")
                VARIANT_MATCHES+=("Latest alias match: $model_tag -> $base_model")
                continue
            fi
            
            # Case 3: If base model doesn't exist but we found variants,
            # and the model name matches, include them
            if [ "$BASE_MODEL_EXISTS" = false ]; then
                MODELS_TO_DELETE+=("$model_tag")
                VARIANT_MATCHES+=("Orphaned variant: $model_tag (base $potential_base not found)")
                continue
            fi
        fi
        
        # Strategy 3: Fuzzy matching for edge cases
        # If the variant starts with the same model name and we haven't found the base,
        # it might be an orphaned variant
        if [ "$BASE_MODEL_EXISTS" = false ] && [[ "$model_tag" =~ ^${model_name_part}: ]]; then
            MODELS_TO_DELETE+=("$model_tag")
            VARIANT_MATCHES+=("Fuzzy match: $model_tag (potential orphaned variant)")
        fi
    done
    
    # Remove duplicates from MODELS_TO_DELETE
    declare -A seen
    UNIQUE_MODELS=()
    for model in "${MODELS_TO_DELETE[@]}"; do
        if [[ ! ${seen[$model]} ]]; then
            seen[$model]=1
            UNIQUE_MODELS+=("$model")
        fi
    done
    MODELS_TO_DELETE=("${UNIQUE_MODELS[@]}")

    # Show debug information about what was found
    if [ ${#VARIANT_MATCHES[@]} -gt 0 ]; then
        echo "INFO: Variant matching results:"
        for match in "${VARIANT_MATCHES[@]}"; do
            echo "  $match"
        done
        echo ""
    fi

    # Handle different scenarios with appropriate messaging
    if [ "$BASE_MODEL_EXISTS" = false ]; then
        if [ ${#MODELS_TO_DELETE[@]} -eq 0 ]; then
            echo "INFO: Base model '$base_model' not found and no variants detected."
            echo "INFO: This could mean:"
            echo "  - The model was never downloaded"
            echo "  - The model name doesn't match any existing models"
            echo "  - No variants were created by this script"
            return 0
        else
            echo "WARNING: Base model '$base_model' not found, but found ${#MODELS_TO_DELETE[@]} variant(s)."
            echo "INFO: These appear to be orphaned variants that will be deleted."
        fi
    else
        echo "INFO: Found base model '$RESOLVED_BASE_MODEL' and ${#MODELS_TO_DELETE[@]} total model(s) to delete."
    fi

    if [ ${#MODELS_TO_DELETE[@]} -eq 0 ]; then
        echo "INFO: No models found to delete."
        return 0
    fi

    # Categorize models for clearer display
    BASE_MODELS=()
    VARIANT_MODELS=()
    
    for model in "${MODELS_TO_DELETE[@]}"; do
        if [[ "$model" =~ -[0-9]+k$ ]]; then
            VARIANT_MODELS+=("$model")
        else
            BASE_MODELS+=("$model")
        fi
    done

    echo "Found ${#MODELS_TO_DELETE[@]} model(s) to delete:"
    
    if [ ${#BASE_MODELS[@]} -gt 0 ]; then
        echo "  Base model(s):"
        for model in "${BASE_MODELS[@]}"; do
            echo "    - $model"
        done
    fi
    
    if [ ${#VARIANT_MODELS[@]} -gt 0 ]; then
        echo "  Variant model(s):"
        for model in "${VARIANT_MODELS[@]}"; do
            echo "    - $model"
        done
    fi
    echo ""

    # Find corresponding Modelfiles with improved matching
    MODELFILES_TO_DELETE=()
    if [ -d "$OUTPUT_DIR" ]; then
        # Try multiple filename patterns to catch all possible Modelfiles
        
        # Pattern 1: Based on the original base model name
        model_base_name_raw=$(echo "$base_model" | cut -d':' -f1)
        model_base_name=$(echo "$model_base_name_raw" | tr '/' '-')
        
        # Pattern 2: Based on resolved base model name (if different)
        if [ "$RESOLVED_BASE_MODEL" != "$base_model" ]; then
            resolved_base_name_raw=$(echo "$RESOLVED_BASE_MODEL" | cut -d':' -f1)
            resolved_base_name=$(echo "$resolved_base_name_raw" | tr '/' '-')
        else
            resolved_base_name="$model_base_name"
        fi
        
        # Search for Modelfiles using both patterns
        for pattern in "$model_base_name" "$resolved_base_name"; do
            for modelfile in "$OUTPUT_DIR"/my-${pattern}-*-*k.modelfile; do
                if [ -f "$modelfile" ]; then
                    # Check if already in array to avoid duplicates
                    duplicate=false
                    for existing in "${MODELFILES_TO_DELETE[@]}"; do
                        if [ "$existing" = "$modelfile" ]; then
                            duplicate=true
                            break
                        fi
                    done
                    if [ "$duplicate" = false ]; then
                        MODELFILES_TO_DELETE+=("$modelfile")
                    fi
                fi
            done
        done
    fi

    if [ ${#MODELFILES_TO_DELETE[@]} -gt 0 ]; then
        echo "Found ${#MODELFILES_TO_DELETE[@]} corresponding Modelfile(s):"
        for modelfile in "${MODELFILES_TO_DELETE[@]}"; do
            echo "  - $(basename "$modelfile")"
        done
        echo ""
    fi

    # Enhanced confirmation prompt with clearer information
    echo "This will delete:"
    if [ ${#BASE_MODELS[@]} -gt 0 ]; then
        echo "  - ${#BASE_MODELS[@]} base model(s)"
    fi
    if [ ${#VARIANT_MODELS[@]} -gt 0 ]; then
        echo "  - ${#VARIANT_MODELS[@]} variant model(s)"
    fi
    echo "  - ${#MODELFILES_TO_DELETE[@]} Modelfile(s)"
    echo ""
    
    if [ "$BASE_MODEL_EXISTS" = false ] && [ ${#VARIANT_MODELS[@]} -gt 0 ]; then
        echo "⚠️  WARNING: The base model '$base_model' was not found, but variants exist."
        echo "   This suggests the base model was already deleted or renamed."
        echo "   Proceeding will delete the orphaned variants."
        echo ""
    fi
    
    read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "INFO: Deletion cancelled."
        return 0
    fi

    # Delete Ollama models
    echo "--- Deleting Ollama Models ---"
    for model in "${MODELS_TO_DELETE[@]}"; do
        echo "Deleting model: $model"
        if ollama rm "$model"; then
            echo "  SUCCESS: Deleted '$model'"
        else
            echo "  ERROR: Failed to delete '$model'"
        fi
    done

    # Delete Modelfiles
    if [ ${#MODELFILES_TO_DELETE[@]} -gt 0 ]; then
        echo "--- Deleting Modelfiles ---"
        for modelfile in "${MODELFILES_TO_DELETE[@]}"; do
            echo "Deleting file: $(basename "$modelfile")"
            if rm -f "$modelfile"; then
                echo "  SUCCESS: Deleted '$(basename "$modelfile")'"
            else
                echo "  ERROR: Failed to delete '$(basename "$modelfile")'"
            fi
        done
    fi

    echo "---"
    echo "Base model deletion completed."
}

list_models() {
    local filter="$1"
    
    echo "OLLAMA BASE MODELS - CONTEXT WINDOW LEADERBOARD"
    echo "================================================"
    
    if [ -n "$filter" ]; then
        echo "Filter: Models containing '$filter'"
        echo ""
    fi
    
    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)

    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    # Array to store model information for sorting
    declare -a MODEL_DATA=()
    declare -a NON_CONFORMING_MODELS=()
    
    for model_tag in $ALL_MODEL_TAGS; do
        # Apply filter if provided
        if [ -n "$filter" ] && [[ "$model_tag" != *"$filter"* ]]; then
            continue
        fi
        
        # Skip empty or malformed model tags
        if [ -z "$model_tag" ] || [[ "$model_tag" =~ ^[[:space:]]*$ ]]; then
            continue
        fi
        
        # Skip generated variant models (those matching the pattern {model}:{params}-{context}k)
        if [[ "$model_tag" =~ :[^:]*-[0-9]+k$ ]]; then
            continue
        fi
        
        # Check if it's a base model (not derived from another)
        modelfile_content=$(ollama show --modelfile "$model_tag" 2>/dev/null || echo "")
        
        if echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
            continue  # Skip derived models
        fi
        
        # Check naming convention
        if ! is_conforming_model_name "$model_tag"; then
            NON_CONFORMING_MODELS+=("$model_tag")
            continue  # Skip non-conforming models from the main listing
        fi
        
        # Get model information
        model_info_text=$(ollama show "$model_tag" 2>/dev/null || echo "")
        
        # Extract parameter size and max context with improved parsing
        param_size_raw=$(echo "$model_info_text" | grep 'parameters' | awk '{print $2}' || echo "")
        max_ctx_raw=$(echo "$model_info_text" | grep 'context length' | awk '{print $3}' || echo "")
        
        # Clean and validate parameter size
        if [ -n "$param_size_raw" ] && [ "$param_size_raw" != "" ]; then
            # Remove any trailing characters and normalize (e.g., "7.24B" -> "7.24B")
            param_size=$(echo "$param_size_raw" | sed 's/[[:space:]]*$//')
        else
            param_size="Unknown"
        fi
        
        # Clean and validate max context - ensure it's a valid integer
        if [ -n "$max_ctx_raw" ] && [[ "$max_ctx_raw" =~ ^[0-9]+$ ]]; then
            max_ctx="$max_ctx_raw"
        else
            max_ctx="0"
        fi
        
        # Calculate estimated memory usage for context (more accurate approximation)
        # Using 2 bytes per token as a conservative estimate for context storage
        if [ "$max_ctx" -gt 0 ] && [[ "$max_ctx" =~ ^[0-9]+$ ]]; then
            # Calculate in KB first to avoid integer overflow and get better precision
            context_kb=$((max_ctx * 2 / 1024))
            
            if [ "$context_kb" -ge 1024 ]; then
                # Convert to MB if >= 1024 KB
                context_mb=$((context_kb / 1024))
                if [ "$context_mb" -ge 1024 ]; then
                    # Convert to GB if >= 1024 MB
                    context_gb=$((context_mb / 1024))
                    context_display="~${context_gb} GB"
                else
                    context_display="~${context_mb} MB"
                fi
            else
                # Show in KB for smaller values
                if [ "$context_kb" -eq 0 ]; then
                    context_kb=1  # Minimum 1 KB
                fi
                context_display="~${context_kb} KB"
            fi
        else
            context_display="Unknown"
        fi
        
        # Validate all components before adding to array
        if [ -n "$model_tag" ] && [ -n "$param_size" ] && [ -n "$max_ctx" ] && [ -n "$context_display" ]; then
            # Store model data: "max_ctx|model_tag|param_size|context_display"
            MODEL_DATA+=("${max_ctx}|${model_tag}|${param_size}|${context_display}")
        fi
    done
    
    # Check if any base models were found
    if [ ${#MODEL_DATA[@]} -eq 0 ]; then
        if [ -n "$filter" ]; then
            echo "No base models found matching filter '$filter'."
        else
            echo "No base models found."
        fi
        echo ""
        echo "Note: Only base models are shown (derived models with 'FROM' statements are excluded)."
        return 0
    fi
    
    # Sort by max context (descending) - using sort with numeric comparison
    IFS=$'\n' SORTED_DATA=($(printf '%s\n' "${MODEL_DATA[@]}" | sort -t'|' -k1,1nr))
    
    # Calculate dynamic width for Model Name column
    max_model_name_length=10  # Minimum width
    for data in "${SORTED_DATA[@]}"; do
        if [[ "$data" != *"|"* ]]; then
            continue  # Skip malformed entries
        fi
        
        IFS='|' read -r max_ctx model_tag param_size context_display <<< "$data"
        
        if [ -n "$model_tag" ] && [ ${#model_tag} -gt $max_model_name_length ]; then
            max_model_name_length=${#model_tag}
        fi
    done
    
    # Print table header
    printf "%-4s | %-${max_model_name_length}s | %-10s | %-11s | %-13s\n" "Rank" "Model Name" "Parameters" "Max Context" "Context Mem"
    printf "%-4s-|-%-${max_model_name_length}s-|-%-10s-|-%-11s-|-%-13s\n" "----" "$(printf '%*s' $max_model_name_length '' | tr ' ' '-')" "----------" "-----------" "-------------"
    
    # Print sorted results
    rank=1
    displayed_count=0
    for data in "${SORTED_DATA[@]}"; do
        # Validate data format before processing
        if [[ "$data" != *"|"* ]]; then
            continue  # Skip malformed entries
        fi
        
        IFS='|' read -r max_ctx model_tag param_size context_display <<< "$data"
        
        # Validate parsed components
        if [ -z "$model_tag" ] || [ -z "$param_size" ] || [ -z "$context_display" ]; then
            continue  # Skip entries with missing data
        fi
        
        # Format max context with commas for readability
        if [ "$max_ctx" -gt 0 ] && [[ "$max_ctx" =~ ^[0-9]+$ ]]; then
            formatted_ctx=$(printf "%'d" "$max_ctx" 2>/dev/null || echo "$max_ctx")
        else
            formatted_ctx="Unknown"
        fi
        
        printf "%-4d | %-${max_model_name_length}s | %-10s | %-11s | %-13s\n" \
            "$rank" "$model_tag" "$param_size" "$formatted_ctx" "$context_display"
        
        rank=$((rank + 1))
        displayed_count=$((displayed_count + 1))
    done
    
    echo ""
    echo "Found $displayed_count conforming base model(s)."
    if [ -n "$filter" ]; then
        echo "Use './ollama-mama ctx --list' to see all base models."
    fi
    
    # Show non-conforming models if any were found
    if [ ${#NON_CONFORMING_MODELS[@]} -gt 0 ]; then
        echo ""
        echo -e "\033[1;33m⚠️  NON-CONFORMING MODELS (excluded from listing):\033[0m"
        for model in "${NON_CONFORMING_MODELS[@]}"; do
            echo -e "\033[1;31m  ✗ $model\033[0m"
        done
        echo ""
        echo -e "\033[1;36mTo fix these models, run:\033[0m"
        echo -e "\033[1;37m  ./ollama-mama model --autorename\033[0m"
    fi
}

autorename_models() {
    echo "--- Starting Model Auto-Rename ---"
    echo "Scanning for models with problematic naming patterns..."
    echo ""
    
    ALL_MODEL_TAGS=$(ollama list | awk 'NR>1 {print $1}' || true)

    if [ -z "$ALL_MODEL_TAGS" ]; then
        echo "ERROR: No Ollama models found. Exiting."
        exit 1
    fi

    # Array to store transformation data
    declare -a TRANSFORMATIONS=()
    
    for model_tag in $ALL_MODEL_TAGS; do
        # Skip empty or malformed model tags
        if [ -z "$model_tag" ] || [[ "$model_tag" =~ ^[[:space:]]*$ ]]; then
            continue
        fi
        
        # Skip already generated variants (those matching the pattern {model}:{params}-{context}k)
        if [[ "$model_tag" =~ :[^:]*-[0-9]+k$ ]]; then
            continue
        fi
        
        # Skip derived models (check if it has FROM statement)
        modelfile_content=$(ollama show --modelfile "$model_tag" 2>/dev/null || echo "")
        if echo "$modelfile_content" | grep -q '^FROM .*:.*'; then
            continue
        fi
        
        # Check if model already conforms to naming convention
        if is_conforming_model_name "$model_tag"; then
            continue
        fi
        
        # Generate transformation for non-conforming models
        new_name=""
        
        # Pattern 1: Size in model name before colon with middle part
        # e.g., "hf.co/TheBloke/deepseek-coder-6.7B-instruct-GGUF:Q4_K_M" -> "hf.co/TheBloke/deepseek-coder-instruct-GGUF-Q4_K_M:6.7B"
        if [[ "$model_tag" =~ ^(.+)-([0-9]+\.?[0-9]*[BM])-(.+):(.+)$ ]]; then
            prefix="${BASH_REMATCH[1]}"
            size="${BASH_REMATCH[2]}"
            middle="${BASH_REMATCH[3]}"
            tag="${BASH_REMATCH[4]}"
            new_name="${prefix}-${middle}-${tag}:${size}"
        
        # Pattern 2: Size in model name before colon without middle part
        # e.g., "microsoft/DialoGPT-30B:Q8_0" -> "microsoft/DialoGPT-Q8_0:30B"
        elif [[ "$model_tag" =~ ^(.+)-([0-9]+\.?[0-9]*[BM]):(.+)$ ]]; then
            prefix="${BASH_REMATCH[1]}"
            size="${BASH_REMATCH[2]}"
            tag="${BASH_REMATCH[3]}"
            new_name="${prefix}-${tag}:${size}"
        
        # Pattern 3: Handle namespace models with size in base name
        # e.g., "namespace/model-6.7B:tag" -> "namespace/model:6.7B-tag"
        elif [[ "$model_tag" =~ ^([^/]+/[^-]+)-([0-9]+\.?[0-9]*[BM]):(.+)$ ]]; then
            namespace_model="${BASH_REMATCH[1]}"
            size="${BASH_REMATCH[2]}"
            tag="${BASH_REMATCH[3]}"
            new_name="${namespace_model}:${size}-${tag}"
        
        # Pattern 4: Simple case with size before colon
        # e.g., "model-7B:tag" -> "model:7B-tag"
        elif [[ "$model_tag" =~ ^([^-]+)-([0-9]+\.?[0-9]*[BM]):(.+)$ ]]; then
            model_name="${BASH_REMATCH[1]}"
            size="${BASH_REMATCH[2]}"
            tag="${BASH_REMATCH[3]}"
            new_name="${model_name}:${size}-${tag}"
        fi
        
        # If we found a transformation, add it to the array
        if [ -n "$new_name" ] && [ "$new_name" != "$model_tag" ]; then
            TRANSFORMATIONS+=("${model_tag}|${new_name}")
        fi
    done
    
    # Check if any problematic models were found
    if [ ${#TRANSFORMATIONS[@]} -eq 0 ]; then
        echo -e "\033[1;32m✓ No models with problematic naming patterns found.\033[0m"
        echo -e "\033[1;32m✓ All models appear to follow the recommended naming convention.\033[0m"
        return 0
    fi
    
    echo -e "\033[1;33mFound ${#TRANSFORMATIONS[@]} model(s) with problematic naming patterns:\033[0m"
    echo ""
    echo -e "\033[1;37mProposed Transformations:\033[0m"
    echo "========================="
    
    for transformation in "${TRANSFORMATIONS[@]}"; do
        IFS='|' read -r original_name new_name <<< "$transformation"
        echo -e "\033[1;31m  $original_name\033[0m"
        echo -e "\033[1;32m    -> $new_name\033[0m"
        echo ""
    done
    
    echo "This will:"
    echo "  - Create ${#TRANSFORMATIONS[@]} new model(s) with corrected names"
    echo "  - Generate corresponding Modelfiles"
    echo ""
    
    read -p "Do you want to proceed with the transformations? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "INFO: Auto-rename cancelled."
        return 0
    fi
    
    # Ask about removing original models
    REMOVE_ORIGINALS=false
    read -p "Do you want to remove the original models after successful rename? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        REMOVE_ORIGINALS=true
        echo "INFO: Original models will be removed after successful transformation."
    else
        echo "INFO: Original models will be kept."
    fi
    
    mkdir -p "$OUTPUT_DIR"
    echo "INFO: Modelfiles will be saved in '$OUTPUT_DIR'"
    echo ""
    
    # Process transformations
    echo "--- Processing Transformations ---"
    
    declare -a SUCCESSFUL_TRANSFORMATIONS=()
    declare -a FAILED_TRANSFORMATIONS=()
    
    for transformation in "${TRANSFORMATIONS[@]}"; do
        IFS='|' read -r original_name new_name <<< "$transformation"
        
        echo "Processing: $original_name -> $new_name"
        
        # Sanitize new name for filename
        new_name_sanitized=$(echo "$new_name" | tr '/' '-' | tr ':' '-')
        modelfile_name="autorename-${new_name_sanitized}.modelfile"
        modelfile_path="$OUTPUT_DIR/$modelfile_name"
        
        # Create Modelfile
        cat > "$modelfile_path" << EOM
# Modelfile for ${new_name}
# Auto-renamed from ${original_name}
# Generated by script on $(date)

FROM ${original_name}
EOM
        
        echo "  CREATED Modelfile: $modelfile_path"
        echo "  CREATING Ollama model '$new_name'..."
        
        if ollama create "$new_name" -f "$modelfile_path"; then
            echo -e "\033[1;32m  SUCCESS: Created '$new_name'\033[0m"
            SUCCESSFUL_TRANSFORMATIONS+=("${original_name}|${new_name}")
        else
            echo -e "\033[1;31m  ERROR: Failed to create '$new_name'\033[0m"
            FAILED_TRANSFORMATIONS+=("${original_name}|${new_name}")
            # Remove the failed Modelfile
            rm -f "$modelfile_path"
        fi
        echo ""
    done
    
    # Remove original models if requested and transformations were successful
    if [ "$REMOVE_ORIGINALS" = true ] && [ ${#SUCCESSFUL_TRANSFORMATIONS[@]} -gt 0 ]; then
        echo "--- Removing Original Models ---"
        for transformation in "${SUCCESSFUL_TRANSFORMATIONS[@]}"; do
            IFS='|' read -r original_name new_name <<< "$transformation"
            echo "Removing original model: $original_name"
            if ollama rm "$original_name"; then
                echo -e "\033[1;32m  SUCCESS: Removed '$original_name'\033[0m"
            else
                echo -e "\033[1;31m  ERROR: Failed to remove '$original_name'\033[0m"
            fi
        done
        echo ""
    fi
    
    # Summary
    echo "--- Auto-Rename Summary ---"
    echo -e "\033[1;32mSuccessfully transformed: ${#SUCCESSFUL_TRANSFORMATIONS[@]} model(s)\033[0m"
    echo -e "\033[1;31mFailed transformations: ${#FAILED_TRANSFORMATIONS[@]}\033[0m"
    echo ""
    
    if [ ${#SUCCESSFUL_TRANSFORMATIONS[@]} -gt 0 ]; then
        echo -e "\033[1;32mSuccessfully renamed models:\033[0m"
        for transformation in "${SUCCESSFUL_TRANSFORMATIONS[@]}"; do
            IFS='|' read -r original_name new_name <<< "$transformation"
            echo "  $original_name -> $new_name"
        done
        echo ""
    fi
    
    if [ ${#FAILED_TRANSFORMATIONS[@]} -gt 0 ]; then
        echo -e "\033[1;31mFailed transformations:\033[0m"
        for transformation in "${FAILED_TRANSFORMATIONS[@]}"; do
            IFS='|' read -r original_name new_name <<< "$transformation"
            echo "  $original_name -> $new_name"
        done
        echo ""
    fi
    
    echo "Auto-rename completed."
}

# --- Main Script Logic ---

# Check arguments
if [ $# -eq 0 ]; then
    show_usage
    exit 1
fi

if [ "$1" != "ctx" ] && [ "$1" != "model" ]; then
    echo "ERROR: First argument must be 'ctx' or 'model'"
    show_usage
    exit 1
fi

# Handle ctx commands
if [ "$1" = "ctx" ]; then
    case "$2" in
    --create)
        if [ $# -ne 2 ]; then
            echo "ERROR: --create expects exactly 2 arguments"
            show_usage
            exit 1
        fi
        create_models
        ;;
    --delete)
        if [ $# -ne 2 ]; then
            echo "ERROR: --delete expects exactly 2 arguments"
            show_usage
            exit 1
        fi
        delete_models
        ;;
    --delete-base)
        if [ $# -ne 3 ]; then
            echo "ERROR: --delete-base expects exactly 3 arguments (including model name)"
            show_usage
            exit 1
        fi
        delete_base_model "$3"
        ;;
    --create-base)
        if [ $# -ne 3 ]; then
            echo "ERROR: --create-base expects exactly 3 arguments (including model name)"
            show_usage
            exit 1
        fi
        create_base_model "$3"
        ;;
    --list)
        if [ $# -eq 2 ]; then
            list_models ""
        elif [ $# -eq 3 ]; then
            list_models "$3"
        else
            echo "ERROR: --list expects 2 or 3 arguments"
            show_usage
            exit 1
        fi
        ;;
    *)
        echo "ERROR: Unknown ctx command '$2'"
        show_usage
        exit 1
        ;;
    esac
fi

# Handle model commands
if [ "$1" = "model" ]; then
    case "$2" in
    --autorename)
        if [ $# -ne 2 ]; then
            echo "ERROR: --autorename expects exactly 2 arguments"
            show_usage
            exit 1
        fi
        autorename_models
        ;;
    *)
        echo "ERROR: Unknown model command '$2'"
        show_usage
        exit 1
        ;;
    esac
fi
